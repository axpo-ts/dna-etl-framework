# Databricks notebook source
from pyspark.sql import SparkSession

spark = SparkSession.builder.getOrCreate()

# COMMAND ----------


catalog_prefix = dbutils.widgets.get("env_catalog_identifier")  # type: ignore # noqa: F821
schema_prefix = dbutils.widgets.get("schema_prefix")  # type: ignore # noqa: F821
schema = "market_data_and_fundamentals"

tables = {
    "intraday_price_volume_flex_xbids": [
        "delivery_start",
        "delivery_end",
        "duration",
        "timeseries_id_ch_actual_too",
        "value",
        "time_file_creation",
        "updated_at_source",
        "run_time_id",
        "project_name_fr_actual_too",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "dayahead_volume_flex_epex": [
        "delivery_start",
        "delivery_end",
        "duration",
        "timeseries_id_ch_actual_too",
        "value",
        "updated_at_source",
        "license",
        "run_time_id",
        "project_name_fr_actual_too",
        "year_month_day",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "fcr_price_amprion": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "afrr_capacity_price_rte": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "up",
        "down",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "afrr_marginal_price_rte": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "prorata_mode",
        "picasso_connection",
        "up",
        "down",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "dayahead_price_epex": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "price",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "imbalance_price_rte": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "precipitation_noaa": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "production_wind_meteologica": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "eic",
        "real_data",
        "fic",
        "p50_fc",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "production_spv_meteologica": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "eic",
        "real_data",
        "fic",
        "p50_fc",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "axpo_trading_fx_forward_curve": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "price",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "commodity",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "egl_che_discount_factor_curve": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "commodity",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "egl_che_cannibalization_factor": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "legacy_delivery_bucket_number",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "commodity",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "egl_che_price_modelled": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "value",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "commodity",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "axpo_trading_price_forward_curve": [
        "id",
        "reference_time",
        "delivery_start",
        "delivery_end",
        "price",
        "duration",
        "geolocation",
        "data_provider",
        "data_source",
        "data_type",
        "license",
        "unit",
        "commodity",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "temperature_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "city",
        "duration",
        "model",
        "level",
        "interval",
        "measure",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "precipitation_forecast_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "city",
        "duration",
        "model",
        "level",
        "interval",
        "measure",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "geopotential_height_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "city",
        "duration",
        "model",
        "level",
        "interval",
        "measure",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "mean_sea_level_pressure_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "city",
        "duration",
        "model",
        "level",
        "interval",
        "measure",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "wind_speed_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "city",
        "duration",
        "model",
        "level",
        "interval",
        "measure",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "global_radiance_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "duration",
        "model",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "snow_depth_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "duration",
        "model",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "clear_sky_radiance_meteomatics": [
        "curve_name",
        "delivery_start",
        "delivery_end",
        "latitude",
        "longitude",
        "value",
        "duration",
        "model",
        "unit",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "fcr_pos_awarded_capacity_power_orca": [
        "signal_id",
        "balance_item_id",
        "timestamp",
        "value",
        "unit_type",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "fcr_neg_awarded_capacity_power_orca": [
        "signal_id",
        "balance_item_id",
        "timestamp",
        "value",
        "unit_type",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "afrr_neg_awarded_capacity_power_orca": [
        "signal_id",
        "balance_item_id",
        "timestamp",
        "value",
        "unit_type",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "afrr_pos_awarded_capacity_power_orca": [
        "signal_id",
        "balance_item_id",
        "timestamp",
        "value",
        "unit_type",
        "license",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
        "table_id",
    ],
    "activation_signal_picasso_swissgrid": [
        "time_stamp_utc",
        "volume",
        "license",
        "unit_type",
        "table_id",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
    ],
    "production_plant_pronovo": [
        "xtf_id",
        "address",
        "post_code",
        "municipality",
        "canton",
        "main_category",
        "sub_category",
        "plant_category",
        "beginning_of_operation",
        "initial_power",
        "total_power",
        "_x",
        "_y",
        "_rescued_data",
        "created_at",
        "created_by",
        "updated_at",
        "updated_by",
    ],
}

for table_name, columns in tables.items():
    # Get existing columns for the table
    table_path = f"{catalog_prefix}silver.{schema_prefix}{schema}.{table_name}"
    existing_columns = set(col.name for col in spark.table(table_path).schema)

    # Check if all required columns exist
    missing_columns = [col for col in columns if col not in existing_columns]
    if missing_columns:
        raise ValueError(f"Table {table_path} is missing columns: {missing_columns}")

    # Proceed with column reordering
    for i, column in enumerate(columns):
        position_clause = "FIRST" if i == 0 else f"AFTER {columns[i - 1]}"
        sql_query = f"ALTER TABLE {table_path} ALTER COLUMN {column} {position_clause}"
        print(sql_query)
        spark.sql(sql_query)
